<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>INDS Data</title>

<script language="javascript">

/////////////////////////////////////////////////
//
// THE FOLLOWING GLOBAL VARIABLES WILL NEED TO BE
// TWEAKED FOR EACH NEW USE OF THIS WEB PAGE.
//
/////////////////////////////////////////////////
//
// START
//
var chans =
    new Array(
        "TimeStamp",
        "Latitude",
        "Longitude",
        "GPS_Alt_MSL",
        "GPS_Altitude",
        "Pressure_Altitude",
        "RADAR_Altitude",
        "Ground_Speed",
        "True_Air_Speed",
        "Indicated_Air_Speed",
        "Mach_Number",
        "Vertical_Speed",
        "True_Heading",
        "Track_Angle",
        "Drift_Angle",
        "Pitch_Angle",
        "Roll_Angle",
        "Slip_Angle",
        "Attack_Angle",
        "Static_Air_Temp",
        "Dew_Point",
        "Total_Air_Temp",
        "Static_Pressure",
        "Dynamic_Pressure",
        "Cabin_Pressure",
        "Wind_Speed",
        "Wind_Direction",
        "Vert_Wind_Speed",
        "Solar_Zenith_Angle",
        "Aircraft_Sun_Elevation",
        "Sun_Azimuth",
        "Aircraft_Sun_Azimuth",
        "GPS_Vertical_Speed",
        "ADC_Baro_Altitude",
        "Potential_Temp",
        "Cabin_Temp",
        "Cabin_Humidity",
        "Acceleration_X",
        "Acceleration_Y",
        "Acceleration_Z",
        "_Latency");

var missionTimes = {
    "None":"http://10.10.3.4/TimeDrive"
}
var title = "DC8 IWG1 Data";
var serverurl      = "/TimeDrive/RBNB/";  	// plugins run on Node
var plotdatachan   = "PNGPlugIn/";
var asciidatachan  = "ToString/";
var timeupdateurl  = "/TimeDrive/time.jpg";
var sourcePath = "DC8-817-TC4_IWG1/";				// plugins run on Node
//
// END
//
/////////////////////////////////////////////////

// ID for the timer that is used to perform automatic refreshes
var refreshTimerID = null;
var refreshTimerPeriod = 5000;

// Array of xmlhttp objects for asynchronously handling the server requests for
// 0-duration text data
var httpRequest = new Array( chans.length );

//
//--------------------------------------------------------------
// When form first loads
function initializeHTML() {
	document.title = title;
	var titleComponent = document.getElementById("pagetitle");
	// Initialize the http request object array
	for (var i = 0; i < httpRequest.length; ++i) {
	    httpRequest[i] = null;
	}
	titleComponent.firstChild.replaceData(0,3000,title);
	updateDisplayedData();
}

//
//--------------------------------------------------------------
// Start the refresh timer
function startRefreshTimer() {
	// If no refresh timer is currently executing, start one
	if (refreshTimerID == null) {
	    refreshTimerID =
		setTimeout("refreshTimerCallback()", refreshTimerPeriod);
	}
}

//
//--------------------------------------------------------------
// Callback which occurs when the refresh timer expires
function refreshTimerCallback() {
	if(refreshTimerID == null) return;  // timer is (in-process) shutdown
	// Refresh data
	updateDisplayedData();
	// Start the timer again
	refreshTimerID = setTimeout("refreshTimerCallback()", refreshTimerPeriod);
}

//
//--------------------------------------------------------------
// Set new timer period
function updateTimerPeriod() {
    // Clear the existing timer (if there is one)
    if (refreshTimerID != null) {
        clearTimeout(refreshTimerID);
	refreshTimerID = null;
    }
    // Get the updated period
    if (document.updateform.period.value != "Manual") {
        // Need to convert to milliseconds
	refreshTimerPeriod = parseFloat(document.updateform.period.value) * 1000;
	startRefreshTimer();
	// alert("Started new timer with period = " + refreshTimerPeriod);
    } else {
	// alert("Set to manual - no refreshes");
    }
    // Do an update right now
    updateDisplayedData();
}

//
//--------------------------------------------------------------
// Update data that the user wishes to see
function updateDisplayedData() {
	// Update the time shown in the TimeDrive image
	document.updateform.timeimage.src = constructMungedURL(timeupdateurl);
	// Update the data
	for (var i = 0; i < chans.length; ++i) {
	    getChannelData(i, sourcePath);
	}
}

//
//--------------------------------------------------------------
// Return the value of the radio button that is checked
// Return empty string if none checked (or if no radio buttons)
function getCheckedRBValue(radioObj) {
	if (!radioObj) {
	    return "";
	}
	var radioLength = radioObj.length;
	if(radioLength == undefined) {
	    if (radioObj.checked) {
		return radioObj.value;
	    } else {
		return "";
	    }
	}
	for (var i = 0; i < radioLength; i++) {
	    if (radioObj[i].checked) {
		return radioObj[i].value;
	    }
	}
	// No radio button must be checked
	return "";
}

//
//--------------------------------------------------------------
// If the user has checked this channel's checkbox, then update only the PNG
// plot, only text data, or both PNG and text data).
function getChannelData(componentID, source) {
	// Here's a way to get the name of the checkbox element in formC0;
	// the checkbox is the first element in the form
	// document.formC0.elements[0].name
	var checkboxComp = document.getElementById("checkboxC" + componentID.toString());
	var imageComp = document.getElementById("imageC" + componentID.toString());
	var textComp = document.getElementById("textDataC" + componentID.toString());
	var chanName = chans[componentID];
	// Reset the text in the text component
	textComp.firstChild.replaceData(0,3000," ");
	if (checkboxComp.checked) {
	    // Display only what the user has chosen to see (based on their
	    // radio button selection)
	    var checkedRB = getCheckedRBValue(document.updateform.datatofetch);
	    if (checkedRB == "") {
		// Don't display any data
		imageComp.src="blank.GIF";
	    } else if (checkedRB == "both") {
		// Display both the PNG plot and text data
		imageComp.src = constructMungedURL(serverurl+plotdatachan+source+chanName);
		requestSingleDataPointAsString(componentID, source+chanName);
	    } else if (checkedRB == "png") {
		// Display only the PNG plot
		imageComp.src = constructMungedURL(serverurl+plotdatachan+source+chanName);
	    } else if (checkedRB == "text") {
		// Display only the text data
		imageComp.src="blank.GIF";
		requestSingleDataPointAsString(componentID, source+chanName);
	    }
	}
	else {
	    imageComp.src="blank.GIF";
	}
}

//
//--------------------------------------------------------------
// Send the request for 0-duration string data to the RBNB using XMLHttpRequest
// NOTE: This is an asynchronous request
function requestSingleDataPointAsString(componentIDI, chanI) {
   	// NOTE: The "z=t" munge tells TimeDrive to force duration=0;
	//       the "dt=s" munge tells WebTurbine to fetch data as string
	var url = constructMungedURL(serverurl+chanI) + "&z=t&dt=s";
	var http = getHTTPObject(); // create the HTTP Object
	http.open("GET", url, true); // do an asynchronous fetch
	// To set an HTTP header field, call http.setRequestHeader("<field>","<value>")
	// As an example, here's how we could set the Authorization field.
	// NOTE: If the browser client has its own Authorization set, then it will
	//       override what we set here!  It must be that the client sets its
	//       fields *after* we set the fields here.
	// http.setRequestHeader("Authorization","Basic Zm9vIG9uIHlvdTogaGVsbG8=");
	// Specify the callback method
	http.onreadystatechange = handleServerResp;
	// Save this http object
	httpRequest[componentIDI] = http;
	http.send(null);
}

//
//--------------------------------------------------------------
// Asynchronous function to handle server response
function handleServerResp() {
    // The idea for this way to handle multiple asynchronous request objects
    // came from: http://www.devx.com/webdev/Article/28695/0/page/1
    // cycle through request objects to see if any are ready with a response.
    // we keep looping even after we find one, because it might not be the one
    // that fired the event (there could be multiple that are ready).
    for (var i = 0; i < httpRequest.length; ++i) {
	// if readyState is 4, we know the return value is ready
	if ( (httpRequest[i] != null) &&
	     (httpRequest[i].readyState == 4) )
	{
	    var dataStr = "Error";
	    if (httpRequest[i].status == 200) {
		dataStr =  httpRequest[i].responseText;
	    }
	    var textComp = document.getElementById("textDataC" + i.toString());
	    textComp.firstChild.replaceData(0,3000,dataStr);
	    httpRequest[i] = null;
	}
    }
}

//
//--------------------------------------------------------------
// Synchronously set the TimeDrive time; we don't care about TimeDrive's
// response (we don't use it here).
function setTimeDriveTime() {
    // Get the URL to set TimeDrive
    if ( (document.updateform.timeselection.value != null) &&
         (document.updateform.timeselection.value != "") )
    {
	var url = document.updateform.timeselection.value;
	var http = getHTTPObject(); // create the HTTP Object
	http.open("GET", url, false); // do a synchronous fetch
	http.send(null);
	// NOTE: We don't care about the server response (TimeDrive will send
	//       back its web interface HTML page).
	// Do an update right now
	updateDisplayedData();
    }
}

//
//--------------------------------------------------------------
// Initiate a new XMLHttp request; this will be used to communicate
// with the TimerDrive server
function getHTTPObject() {
  var xmlhttp;
  /*@cc_on
  @if (@_jscript_version >= 5)
    try {
      xmlhttp = new ActiveXObject("Msxml2.XMLHTTP");
    } catch (e) {
      try {
	xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
      } catch (E) {
	xmlhttp = false;
      }
    }
  @else
  xmlhttp = false;
  @end @*/
  if (!xmlhttp && typeof XMLHttpRequest != 'undefined') {
    try {
      xmlhttp = new XMLHttpRequest();
    } catch (e) {
      xmlhttp = false;
    }
  }
  return xmlhttp;
}

//
//--------------------------------------------------------------
// Show raw channel data (either text using ToString plugin or download binary
function showChannelDataAsTextOrBinary(flag, componentID, source) {
	var chanName = chans[componentID];
	var mungedURL = "";
	if (flag == 0) {
	    mungedURL = constructMungedURL(serverurl+asciidatachan+source+chanName);
	} else {
	    mungedURL = constructMungedURL(serverurl+source+chanName);
	}
	window.open(mungedURL);
}

//
//--------------------------------------------------------------
// Construct Munged URL
function constructMungedURL(channel) {
	now = new Date();
	mungedURL = channel + "?i=" + now.valueOf();  // i= fake out browser cache
	return mungedURL;
}

//
//--------------------------------------------------------------
// Write html entry for channel data entry
function writeChannelHtml(componentID, source) {
	// This is an example of the kind of HTML code this method creates:
	// <tr>
	// <td align=left><input type="checkbox" id="checkboxC1" name="Latitude" onClick="getChannelData(1, sourcePath)"><b>TimeStamp</b></td>
	// <td><input type="button" onclick="showChannelDataAsTextOrBinary(0, 1, sourcePath)" value="ASCII"></td>
	// <td><input type="button" onclick="showChannelDataAsTextOrBinary(1, 1, sourcePath)" value="binary"></td>
	// <td><img name = "C1Image" id="imageC1" src="blank.GIF"></td>
	// <td><span id="textDataC1">.</p></td>
	// </tr>
	var chanName = chans[componentID];
	document.write("<tr>\n");
	document.write("\t<td align=left><input type=\"checkbox\" id=\"checkboxC" + componentID.toString() + "\" name=\"" + chanName + "\" onClick=\"getChannelData("+ componentID + ", " + source + ")\"><b>" + chanName + " </b></td>");
	document.write("\t<td><input type=\"button\" onclick=\"showChannelDataAsTextOrBinary(0," + componentID + "," + source + ")\" value=\"ASCII\"></td>");
	document.write("\t<td><input type=\"button\" onclick=\"showChannelDataAsTextOrBinary(1," + componentID + ", "+source+")\" value=\"binary\"></td>");
	document.write("\t<td><img name = \"C" + componentID.toString() + "Image\" id=\"imageC" + componentID.toString() + "\" src=\"blank.GIF\"></td>");
	// Use <span> instead of <p> for the text field
	// document.write("\t<td><p id=\"textDataC" + componentID.toString() + "\">&nbsp;</p></td>");
	document.write("\t<td><span id=\"textDataC" + componentID.toString() + "\">&nbsp;</span></td>");
	document.write("</tr>\n");
}

//--------------------------------------------------------------
</script>

<STYLE TYPE="text/css">
    .pagetitleStyle
    {
	font-size: 150%;
	font-weight: bold;
	text-align: center;
	vertical-align: middle;
    }
</STYLE>
</head>
<body bgcolor="antiquewhite" onload="initializeHTML()">
<center>
<p class="pagetitleStyle" id="pagetitle">INDS Data</p>
</center>
<p><a href="#directions">How to use this page</a></p>
<form name="updateform">
<b>Data to Fetch:</b>&nbsp;&nbsp;
<INPUT TYPE=RADIO NAME="datatofetch" VALUE="png" onClick="updateDisplayedData()" CHECKED>Strip chart&nbsp;
<INPUT TYPE=RADIO NAME="datatofetch" VALUE="text" onClick="updateDisplayedData()">Numeric value&nbsp;
<INPUT TYPE=RADIO NAME="datatofetch" VALUE="both" onClick="updateDisplayedData()">Both
<br>
<br>
<b>Data Refresh:</b>&nbsp;&nbsp;
<!-- Don't have an auto-refresh for now; our concern is that the user               -->
<!-- will leave the browser with a bunch of channels being auto-refreshed           -->
<!-- and INDS will get bogged down with all the requests.                           -->
<!-- Possible fixes/firewalls:                                                      -->
<!-- 1. Limit the minimum refresh period (don't offer 1 sec refresh, for instance). -->
<!-- 2. In updateTimerPeriod(), have another longer timer - say 1 hour - and after  -->
<!--    that period expires, set the auto-refresh back to Manual.                   -->
<!-- <select name="period" onchange="updateTimerPeriod()"> -->
<!-- <option value="Manual">Manual                         -->
<!-- <option value=10>10sec                                -->
<!-- <option value=10>20s                                  -->
<!-- <option value=30>30s                                  -->
<!-- <option value=60>1min                                 -->
<!-- <option value=120>2m                                  -->
<!-- <option value=300>5m                                  -->
<!-- </select>                                             -->
<!-- &nbsp;&nbsp;                                          -->
<input type="button" value="Update Now" onclick="updateDisplayedData()">
<br>
<br>
<b>Mission TimeMarks:</b>&nbsp;&nbsp;
<select name="timeselection">
<script type="text/javascript">
    // Fill the select component with times from the missioneTimes hashtable
    if (missionTimes != null) {
	for (var n in missionTimes) {
	    document.writeln("<option value=\"" + missionTimes[n] + "\">" + n);
	}
    }
</script>
</select>
<input type="button" value="Go" onclick="setTimeDriveTime()">
<br>
<br>
<img name="timeimage" src="blank.GIF">
</form>
<h2><a name="rawdata">Select Data Channels:</a></h2>
<table border=1 cellpadding="1%">
<script type="text/javascript">
	// Add channel selection HTML code
	for (var i = 0; i < chans.length; ++i) {
	    writeChannelHtml(i, "sourcePath");
	}
	checkboxComp = document.getElementById("checkboxC3");
	checkboxComp.checked=1;
</script>
</table>
<p>
<a name="directions">
<h2>How to use this page:</h2>
<li>Specify what data to fetch by choosing a "Data to Fetch" radio button.
<li>Select one or more channels from the list of data channels below.
<li>Specify the time and duration using <a href=http://rbnb.net/TimeDrive>Time Drive</a> (see frame below).
<li>Times are referenced to most recent data (<i>right edge of data plot</i>).
<li>Click "Update Now" to fetch new data.
<li>To view data for a particular mission, choose the desired "Mission TimeMark" and click the "Go" button.
<li>To get ASCII or binary data, click on the "ASCII" or "binary" button for the desired channel.
</p>
<center>
<a href=http://rbnb.net>INDS Home Page</a>
<br>
<a href=http://rbnb.creare.com>RBNB Home Page</a>
</center>
</body>
</html>
